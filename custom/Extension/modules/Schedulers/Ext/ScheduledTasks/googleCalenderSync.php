<?phpif (!defined('sugarEntry') || !sugarEntry)    die('Not A Valid Entry Point');require_once('custom/include/Google/GoogleHelper.php');require_once("include/utils/encryption_utils.php");require_once('custom/modules/Schedulers/license/OutfittersLicense.php');require_once("modules/Administration/Administration.php");$job_strings[] = 'googleCalenderSync';function googleCalenderSync(){	require('custom/modules/Schedulers/license/config.php');    if (OutfittersLicense::validateModule()) {        $admin = new Administration();        $admin->retrieveSettings();        if (isset($admin->settings[$outfitters_config['shortname'].'_validated_users']) && $admin->settings[$outfitters_config['shortname'].'_validated_users'] == true) {            $_SESSION['dcheckAlldayFunc'] = 1;			if(GoogleHelper::check_column_if_exist($GLOBALS['sugar_config']['dbconfig']['db_name'],'users', 'enable_gsync')){					$gh                           = new GoogleHelper();				$json                         = getJSONobj();				//increasing limits				set_time_limit(9000);				ini_set('memory_limit', '2048M'); //blacklist while package scan				$sql       = "SELECT 						DISTINCT users.id,users.user_name,users.gmail_id,users.gmail_pass,users.lastsync_calendar,rt_gsync.prefrences					FROM users 					LEFT JOIN rt_gsync ON rt_gsync.id=users.id AND rt_gsync.deleted='0'					WHERE 						users.deleted='0' AND 						users.status='Active' AND enable_gsync=1";				$res       = $GLOBALS['db']->query($sql);				$processed = array();				while ($row = $GLOBALS['db']->fetchByAssoc($res)) {					try {						/*user gsync prefrences*/						$prefrences = $json->decode(html_entity_decode(base64_decode($row["prefrences"])));						/*default settings only calendar sync is active*/						if (empty($prefrences)) {							$prefrences = Array(								"schedulers" => Array(									"calendar_google_to_sugar" => true,									"calendar_sugar_to_google" => true,									"contacts_google_to_sugar" => false,									"contacts_sugar_to_google" => true,									"documents_google_to_sugar" => true,									"documents_sugar_to_google" => true								)							);						}						if(!isset($prefrences['schedulers']['calendar_meetings'])){							$prefrences['schedulers']['calendar_meetings']=true;						}						if(!isset($prefrences['schedulers']['calendar_calls'])){							$prefrences['schedulers']['calendar_calls']=true;						}						if(!isset($prefrences['schedulers']['calendar_tasks'])){							$prefrences['schedulers']['calendar_tasks']=true;						}												$gh->prefrences = $prefrences;						/*user gsync prefrences*/						if (!empty($row['gmail_id']) && !empty($row['gmail_pass'])){							if (in_array(strtolower($row['gmail_id']), $processed)) {								$GLOBALS['log']->fatal("This email (" . $row['gmail_id'] . ") is configured in multiple users settings,skipping....");								continue;							} else {								$processed[] = strtolower($row['gmail_id']);							}							$GLOBALS['log']->fatal('STARTED: Calendar sync: ' . $row['user_name'] . '(' . $row['gmail_id'] . ')');							if (empty($row['lastsync_calendar']) || !isset($row['lastsync_calendar'])) {								$row['lastsync_calendar'] = '2013-01-01 01:01:01';							}														$gh->performSync($row['gmail_id'], blowfishDecode(blowfishGetKey('encrypt_field'), $row['gmail_pass']), $row['id'], $row['lastsync_calendar'], 'calendar');														$GLOBALS['log']->fatal('COMPLETED: Calendar sync: ' . $row['user_name'] . '(' . $row['gmail_id'] . ')');						}					}					catch (Exception $ex) {						$GLOBALS['log']->fatal('ERROR:' . $ex->getMessage());					}				}				unset($_SESSION['dcheckAlldayFunc']);				return true;			}else{				$GLOBALS['log']->fatal('Gmail Sync failed in CRON run. do quick repair and rebuild first.');				//return false;			}        } else {            $GLOBALS['log']->fatal('Gmail Sync failed in CRON run. You enabled more than allowed users for GSync');            return false;        }    } else {        $GLOBALS['log']->fatal('Gmail Sync failed in CRON run. Unable to validate key.');        return false;    }}